package test0815._01extends;


/*
面向对象的三大特征：封装  继承  多态
    继承性：（共性抽取）
        将多个子类（派生类）相同的属性和行为抽取出来形成一个单独的父类（超类/基类），子类继承父类，可以拥有父类
        所有非私有的属性和行为
        继承是多态的前提，没有继承就没有多态
    定义父类的格式：一个普通的类
        public class 父类的名称{}
    定义子类的格式
        public class 子类的名称 extends 父类的名称{}
在继承关系中，成员变量重名时，创建子类访问成员变量：
1、直接访问  子类.成员变量
    等号左边是谁就优先用谁，没有则向上找父类，父类没有则编译报错
2、直接访问  子类.成员方法
    这个方法属于谁，就优先用谁，没有则向上找父类，父类没有编译报错
区分子类成员方法中重名的三种变量：
    局部变量   直接写变量名   通过就近原则查找
    子类的成员变量    this.成员变量
    父类的成员变量    super.成员变量

在继承关系中，成员方法重名时，创建子类访问成员方法：
    创建的对象是谁就优先用谁，没有则向上找父类，父类没有则编译报错

覆盖重写（Override）（复写）
    在继承关系中，方法名相同，参数列表也相同  就叫做方法的覆盖重写
特点：
    创建的是子类对象优先用子类，子类没有找父类
注意事项：
    1、注解：@Override  写在方法上面，用于检测该方法是否是正确的覆盖重写
        如果本身就是正确的覆盖重写，不加注解也可以
    2、子类方法的返回值必须小于等于父类方法的返回值范围
        Object类是所有类的最高父类，String可以看作是Object的一个子类
    3、子类方法的权限修饰符必须大于等于父类方法的权限修饰符
        public protected  (default) private
        (default):不是一个关键字  而是什么都不写

覆盖重写使用场景：
    在不修改一个类的源代码时，想对这个类的一些功能加强时，就可以继承这个类，对这个类的
    某一个方法覆盖重写

覆盖重写（Override）：方法名相同，参数列表也相同
重载（Override）：方法名相同，参数列表不同


在继承关系中，父类构造方法访问特点：
    1、子类构造方法中会默认隐含赠送一个super()  调用父类无参构造
    2、子类构造方法可以访问父类重载构造方法
    3、调用父类的构造方法 super() 必须是在子类构造方法中的第一个语句
    4、如果手动写了super(参数) 调用了父类的有参构造，super()则不会赠送
    5、只有子类的构造方法才能调用父类的构造方法

super的用法：
    调用父类的成员变量  super.成员变量
    调用父类的成员方法  super.成员方法
    调用父类的构造方法  super.([参数])   必须是构造方法中的第一个语句

this的用法：
    调用本类的成员变量   this.成员变量
    调用本类的成员方法   this.成员方法
    调用本类的构造方法   this([参数])    必须是构造方法中的第一个语句

java中继承的特点：
    1、java中是单继承（亲爸爸只有一个）  但是可以多级继承
    2、一个父类可以被多个子类继承

* */
public class Test01_extends {
    public static void main(String[] args) {
        Teacher teacher = new Teacher();
        teacher.age = 29;
        teacher.name = "小李";
        teacher.eat();
        teacher.sleep();

        Students students = new Students();
        students.name = "小张";
        students.age = 19;
        students.eat();
        students.sleep();
    }
}
